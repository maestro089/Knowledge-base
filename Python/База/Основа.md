1. Что такое Pep и PEP8?
    
    1. PEP - это предложения по развитию Python
    2. PEP8 - это style guide того, как должен выглядеть код
2. Какие есть типы данных и какие из них изменяемые/неизменяемые ?
    
    1. Неизменяемые:
        1. str
        2. bytes
        3. int
        4. float
        5. complex
        6. bool
        7. turple
        8. frozenset
    2. Изменяемые:
        1. list
        2. set
        3. dict
        4. bytearray
        5. memoryview
3. Что такое виртуальное окружение ? Зачем оно нужно ? Какие инструменты для этого используются?
    
    1. Помогает разграничить локальный и глобальный пайтон
4. Можно ли изменить элемент в кортеже, если кортеж - неизменяемый тип данных?
    
    1. Можно изменить внутри изменяемые типы данных:
    
    ```python
    a=([],1)
    
    a[0].append(2)
    
    print(a) ## ([2], 1)
    
    ```
    
5. Что такое list, set, dict comprehensions? Приведи примеры использования. 1.
    
    ```python
    a = []
    for i in range(5)
    	a.append(i)
    print(a) //[0,1,2,3,4]
    
    ##list comprehensions
    ----------------------------
    a=[i for i in range(5)]
    print(a) //[0,1,2,3,4]
    ----------------------------
    a=[i for i in range(5) if i % 2 == 0]
    print(a) //[0,2,4]
    ----------------------------
    ##set comprehensions
    a={i for i in range(5) if i % 2 == 0}
    print(a) //{0,2,4}
    ----------------------------
    ##dict comprehensions
    a={i: i ** 2 for i in range(5) if i % 2 == 0}
    print(a) //{0:0,2:4,4:16}
    ```
    
6. Какая разница между == и is ?
    
    1. is - ссылается на объект, а == сравнивает элементы
        
        ```python
        a=[1,2,3]
        b=[1,2,3]
        
        print (a==b) ##True
        ----------------------
        a=[1,2,3]
        b=[1,2,3]
        c=a
        
        print (a is b) ##False
        print (a is c) ##True
        ```
        
7. Что такое глубокая(deep) и поверхностная(shallow) копия ? Зачем они нужны ? Как их сделать ? 1.
    
    ```python
    a = [1,[2]]
    b = a
    
    b.append(3)
    b[1].append(4)
    
    print(a)## [1,[2,4],3]
    -----------------------------
    ##поверхностная - создает копию самого объекта, но ссылки
    ## на все внутренние объекты будут сохранены
    import copy
    
    a = [1,[2]]
    b = copy.copy(a)
    
    b.append(3)
    b[1].append(4)
    
    print(a)## [1,[2,4]]
    -------------------------
    ##глубокая-копирует сам объект и рекурсивно копирует
    ## все внутренние объкты в новую память
    import copy
    
    a = [1,[2]]
    b = copy.deepcopy(a)
    
    b.append(3)
    b[1].append(4)
    
    print(a)## [1,[2]]
    
    -------
    ## варианты создания поверхностной копии 
    b = list(a)
    b = a[:]
    b = [i for i in a]
    b = a.copy()
    ```
    
8. Как работают операторы and, or, not операторы? Что они возвращают? 1.
    
    ```python
    ## not - приводит к булевому значению 
    print(not[])#True
    print(not[1,2,3])#False
    
    ##and or 
    # and - проверяет первый операнд. Если первый тру, то возвращает второй операнд
    # Если первый фолс - то возвращается он 
    print([] and 123)# []
    ----
    # or- проверяет первый операнд. Если первый тру, то возвращает первый операнд
    # Если первый фолс - то возвращается второй
    print([] or 123)# 123
    ```
    
9. Как работает разрешение пространств имен в Python? Как работает правило LEGB(Local, Enclosing, Global, Buillt-in)
    
    1. Когда мы обращаемся к имени, то сначала пайтон пытается искать его в Local области видимости, потом в Enclosing (внешней), потом в Global и наконец в Buillt-in
    
    ```python
    str = "global"
    
    def outer():
    	str="enclosing"
    	
    	def inner():
    		str = "local"
    		print(str)
    
    	inner()
    
    outer()
    ```
    
10. Как работают операторы global и nonlocal? 1.
    
    ```python
    a=1
    
    def outer():
    	b=1
    	
    	def inner():
    #меняем локальной области видимости
    		a=2
    		b=2
    	inner()
    	print(f'a={a}')#a=1
    	print(f'b={b}')#b=1
    	--------------------
    a=1
    
    def outer():
    	b=1
    	
    	def inner():
    		global a # для глобальных
    		a=2
    		nonlocal b # для внешних
    		b=2
    	inner()
    	print(f'a={a}')#a=2
    	print(f'b={b}')#b=2
    	
    ```
    
11. map, filter, zip
    
    1. map - применяет функцию к каждому элементу коллекции
    2. filter - применяет некоторую функцию к каждому элементу коллекции и если функция возвращает тру, то он остается в последовательности
    3. zip - она может пройтись сразу по нескольким коллекциям до тех пор пока в одной из коллекций не закончатся элементы