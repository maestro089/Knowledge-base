# Как Posgres хранит данные
	Данные хранятся в файлах (Страницы) размером в 8 кб. Страница, это минимальный объем данных, которые БД может записать или прочитать.
	После считывания страницыс диска она помещается в буферный кеш и хранится там,пока другие данные ее ны вытеснят.
###### TOAST (The Oversized Attribute Storage Technique)
https://habr.com/ru/companies/postgrespro/articles/710104/
	TOAST представляет собой специальные таблицы («тост-таблицы»), невидимые для пользователя, в которые большие значения помещаются нарезанными на кусочки – «тосты». При этом оригинальное значение в исходной таблице подменяется на ссылку специального вида – TOAST Pointer (TOAST-указатель), содержащую служебную информацию – ID тост-таблицы,

# EXPLAiNE
#### sec scan - полное сканирование 
###### Разбор вывода на примере простого SELECT

```
Seq Scan on users  (cost=0.00..100613.12 rows=5201012 width=46) (actual time=1.362..687.424 rows=5201000 loops=1)
Planning Time: 0.123 ms
Execution Time: 816.396 ms
```

- cost - цена выполнения узла (Цена вывода первой строки .. цена вывода всех строк)
```sql
--Оценка ресурсов считывания
select
	relpages, --количество страниц таблицы
	current_setting('seq_page_cost'), --строимость чтения одной страницы
	relpages * current_setting('seq_page_cost')::int as total --итог = 48603
from pg_class 
	where relname = 'users'

```

```sql
--Оценка стоимость ресурсов процессора
select
	reltuples, --количество строк
	current_setting('cpu_tuple_cost'), --строимость обработки одной строки
	reltuples * current_setting('cpu_tuple_cost')::float as total --итог = 52010.12
from pg_class where relname = 'users'
```
В конце сложим итоги и получим cost = 48603 + 52010.12 = 100 613,12

В конце нужно сложить два результата
- rows в первом случае - планируемое количество строк
- rows во втором случае - действительное количество строк
#### index scan - индексное сканирование
Запрос:
```sql
explain analyse select * from users where id = 500
```
Результат:
```
Index Scan using users_pkey on users  (cost=0.43..8.45 rows=1 width=46) (actual time=0.654..0.659 rows=1 loops=1)
  Index Cond: (id = 500)
Planning Time: 0.503 ms
Execution Time: 0.862 ms
```

Так как поиск идет по полю с индексом (Первичный ключ), то БД использует index scan. Но если равенство поменять на < или >, то будет уже sec scan. Это происходит из за селективности. То есть если мы запросили малое количество строк, то будет работать index scan иначе будем читать всю таблицу index scan.

#### bitmap heap scan - сканирование по битовой карте
Запрос:
```sql
explain analyse select * from users where id = 100 or id = 123
```
Результат:
```
Bitmap Heap Scan on users  (cost=8.88..16.87 rows=2 width=46) (actual time=0.199..0.209 rows=2 loops=1)
  Recheck Cond: ((id = 100) OR (id = 123))
  Heap Blocks: exact=2
  ->  BitmapOr  (cost=8.88..8.88 rows=2 width=0) (actual time=0.182..0.185 rows=0 loops=1)
        ->  Bitmap Index Scan on users_pkey  (cost=0.00..4.44 rows=1 width=0) (actual time=0.160..0.160 rows=1 loops=1)
              Index Cond: (id = 100)
        ->  Bitmap Index Scan on users_pkey  (cost=0.00..4.44 rows=1 width=0) (actual time=0.020..0.020 rows=1 loops=1)
              Index Cond: (id = 123)
```
Активируется, когда идет поиск по индексам и есть логические операторы
#### index only scan - сканирование только индекса
#### nested loop - вложенные циклы
#### hash join - соединение хешированием
#### merge join - соединение слиянием

Методы оптимизатора можно отключать
```sql
SET enable_seqscan = off;
SET enable_indexscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = off;

SET enable_nestloop = off;
SET enable_hashjoin = off;
SET enable_mergejoin = off;
```

